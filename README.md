# BofhContract

BofhContract.sol implements on-chain execution of swap paths. It stores and manages its own wallet of credit for 
the base L2 token which - at deploy time - is specified for the contract instance.

## Implemented features:

- contract instance lifecycle management
- management of on-contract stored funds (for a single `baseToken`)
- token-agnostic (`baseToken` is only set at deploy time, not hardwired) 
- all state-changing calls are protected by single-admin ACL 
- transferable ownership of admin rights
- support for deferred funding injections
- support for funding retrieval
- multi-way swap with no explicit limitation
- multi-exchange router implementation (at the time, only compatible with UniswapV2 compliant pools)

## How to instantiate the contract for production use:

The short version:

- sign a contract deploy transaction
- approve some balance amount of the `baseToken` to the contract address
- call `adoptAllowance()`

## How to retrieve stored funds:

- call `withdrawFunds()`

## How to kill a contract instance

- call `kill()`
- This also returns any stored funding to the caller

## How to replace the admin address

- call `changeAdmin(newAddress)`

## I forgot which address is the `baseToken` or the admin for a contract instance, so...

There are two public calls any address can call:

- `getAdmin()`
- `getBaseToken()`

Hope you still have the private key to whatever `getAdmin()` returns, or the contract and its funds are lost forever.


## Revert error messages:

| Message | Condition 	|
|---	  |---	        |
| `BOFH:SUX2BEU` 	                | Unauthorized call. (Call must be signed by current admin address)	|
| `BOFH:TRANSFER_FAILED` 	        | Failed token fund transfer to the swap path's entry pool	|
| `BOFH:PAIR_NOT_IN_PATH` 	        | One of the pools in the swap list breaks the path 	|
| `BOFH:INSUFFICIENT_INPUT_AMOUNT` 	| During the path execution, the current token balance decreased to zero 	|
| `BOFH:INSUFFICIENT_LIQUIDITY`	    | During the path execution, a pair was found with no liquidity 	|
| `BOFH:PATH_TOO_SHORT` 	        | Minimum swap path length is 2	|
| `BOFH:GIMMIE_MONEY`	            | Current contract funds are < than the required `initialAmount` 	|
| `BOFH:NON_CIRCULAR_PATH` 	        | The proposed swap path does not terminate with the `baseToken` 	|
| `BOFH:GREED_IS_GOOD` 	            | The final balance of the swap path does not meet or exceed the specified `expectedFinalAmount` constraint 	|
 
Any error string not starting in `BOFH:` is being generated by calls dispatched to external contracts such as tokens and pools.


# Low-level argument encoding:

The ABI has been put together to be consumed by web3 (yuck) but also enabling easy lower-level access.
In particular, the adopted encoding saves a minimum of 96 byte of calldata storage per transaction.

This is done at the expense of argument encoding clarity, which is why this paragraph exists.

All of the runtime call parameters are passed to the contract's entry point in the form of 
a packed uint256 array of data.

Before describing its contents, note that this encoding is radically different than a variable-length array with
a bunch of uint265 in it:
Solidity ABI encodes variable-length arrays with a uint256 length prequel stating how many of the trailing
uint256 blocks  are part of the array. This wastes valuable blockchain storage (which is EXPENSIVE).

For this reason the length of the passed array is actually encoded in the method selector.

These are the method_ids of the entry points to call, depending on the length of the passed array.

| args.length | prototype | selector (autocomputed by web3) | alias selector
|---          |---        |---                              |---        
| 3  | `multiswap(uint256[3])` | `0x86a99d4f` | `0xab25564d` for `multiswap3()`
| 4  | `multiswap(uint256[4])` | `0xdacdc381` | `0xdaa5960e` for `multiswap4()`
| 5  | `multiswap(uint256[5])` | `0xea704299` | `0x7aae10f1` for `multiswap5()`
| 6  | `multiswap(uint256[6])` | `0xa0a3d9d9` | `0x3ca172e4` for `multiswap6()`
| 7  | `multiswap(uint256[7])` | `0x0ef12bbe` | `0xb009862e` for `multiswap7()`
| 8  | `multiswap(uint256[8])` | `0xb4859ac7` | `0xabdef753` for `multiswap8()`
| 9  | `multiswap(uint256[9])` | `0x12558fb4` | `0xc1a8841b` for `multiswap9()`
| 10 | `multiswap(uint256[10])` | `0x2dbdcebb` | `0xd461c260` for `multiswap10()`


The array structure can be unpacked with this semantic scheme:

    args[0] --> pool0data
    args[1] --> pool1data
    args[2] --> pool2data
    args[N] --> poolNdata
    args[args.length-1] --> amountData

    poolNdata --> (poolFeePPM << 160) | poolAddress
    amountData --> uint128(initialAmount) | (uint128(expectedAmount) << 128) 

